function symlink_contents_to_dir() {
if [[ -z "$1" ]]; then
echo "arg 1 to symlink_contents_to_dir is unexpectedly empty"
exit 1
fi
if [[ -z "$2" ]]; then
echo "arg 2 to symlink_contents_to_dir is unexpectedly empty"
exit 1
fi
local target="$2"
mkdir -p "$target"
if [[ -f "$1" ]]; then
symlink_to_dir "$1" "$target"
elif [[ -L "$1" ]]; then
local actual=$(readlink "$1")
symlink_contents_to_dir "$actual" "$target"
elif [[ -d "$1" ]]; then
SAVEIFS=$IFS
IFS=$'
'
local children=($(find -H "$1" -maxdepth 1 -mindepth 1))
IFS=$SAVEIFS
for child in "${children[@]:-}"; do
symlink_to_dir "$child" "$target"
done
fi
}
function symlink_to_dir() {
if [[ -z "$1" ]]; then
echo "arg 1 to symlink_to_dir is unexpectedly empty"
exit 1
fi
if [[ -z "$2" ]]; then
echo "arg 2 to symlink_to_dir is unexpectedly empty"
exit 1
fi
local target="$2"
mkdir -p "$target"
local basename=$(basename "$1")
if [[ "$basename" != *.ext_build_deps ]]; then
source="$(readlink -f $1)"

# we symlink the ext_build_deps as well but we delete it after :)
# this is a huge performance improvement than the original recursive version
# so these extra copies are an okay performance loss
if [[ -d "$source" ]] || [[ -f "$source" ]]; then
if [[ -d "$source" ]]; then
cp -prsL "$source" "$target"
SAVEIFS=$IFS
IFS=$'
'
# In order to be able to use `replace_in_files`, we ensure that we create copies of specfieid
# files so updating them is possible.
local files_to_copy=($(find -L "$source" -type f \( -name "*.pc" -or -name "*.la" -or -name "*-config" -or -name "*.mk" -or -name "*.cmake" \) -printf "%P\n"))
IFS=$SAVEIFS
for f in "${files_to_copy[@]:-}"; do
if [[ "$f" != "" ]]; then
dest="$target/$basename/$f"
src=$(readlink -f "$source/$f")
# we have to delete the file because it is a symlink to the original file and we can't overwrite the copy to it
rm "$dest" || true
cp -pf "$src" "$dest" && chmod +w "$dest" && touch -r "$src" "$dest"
fi
done
else
mkdir -p $target
if [[ "$source" == *.pc || "$source" == *.la || "$source" == *-config || "$source" == *.mk || "$source" == *.cmake ]]; then
cp -pf "$source" "$target" && chmod +w "$target" && touch -r "$source" "$target"
else
ln -sf "$source" "$target"/$basename
fi
fi
fi
fi

}
symlink_contents_to_dir $SOURCE_DIR $TARGET_DIR